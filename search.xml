<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一站,我的博客</title>
    <url>/2023/11/13/hello-world/</url>
    <content><![CDATA[<p>当我最初打算搭建一个博客时,以为这将是一项轻松的任务.但很快就意识到实际工作远比预期复杂.</p>
<p>首先,我在MDN上系统地学习了HTML&#x2F;CSS和JavaScript前端开发的核心技术.随着学习的深入,我开始动手实践我的第一个项目.起初的尝试总让我感觉设计粗糙,缺乏美感.这时,我意识到作为新手虽然要通过实践来学习,但也没必要始终从零开始.于是,我找到了Hexo这个框架,希望能简化我的工作.使用Hexo确实方便了不少,但我仍对细节不满意.调整样式&#x2F;增加功能,这成了我日常工作的一部分.我遇到了各种问题:Hexo报错&#x2F;Git仓库报错&#x2F;包依赖冲突&#x2F;GitHub上传报错&#x2F;功能BUG等等.之前,我对Git&#x2F;GitHub甚至基本的环境配置都知之甚少,现在需要面临这一系列的问题.面对连续不断的报错,我曾感到无助和困惑.错误信息对我来说就像天书,我甚至不明白为什么会出错.然而我问自己:”我就这样放弃吗?我的旅程就此结束?”答案是NO!我继续去查阅大量文档,以及在Google上寻找解答,最终克服了所有挑战.</p>
<p><strong>现在,这个博客不仅是我分享知识的平台,更是见证我成长的舞台.</strong></p>
<h1 id="梦开始的地方"><a href="#梦开始的地方" class="headerlink" title="梦开始的地方"></a>梦开始的地方</h1><p>之前可以说是零编码基础了,CS50x是我一切兴趣的源头.</p>
<p>第0周开始(没有1开始,马兰教授是从第零周开始,意味着从头学起),马兰教授循序渐进的讲课方式,更重要的是他在最初就向学生灌输正确的思考方式.还有那场著名的手撕电话簿表演,那让我大开眼界,原来课程可以这么生动有趣!于是,我一口气听完了week0与week1的内容.起初我以为20至30小时内就能快乐地完成整个课程,但每周的课后题却让我停下了脚步.</p>
<p>Week1的练习之一是创造一个像马里奥那样的金字塔图案,需要打印出如下形式的砖块:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">       #  #</span><br><span class="line">      ##  ##</span><br><span class="line">     ###  ###</span><br><span class="line">    ####  ####</span><br><span class="line">   #####  #####</span><br><span class="line">  ######  ######</span><br><span class="line"> #######  #######</span><br><span class="line">########  ########</span><br></pre></td></tr></table></figure>
<p>那时我还是个循环都用不好的小菜鸡,然后看到马里奥后还有两个更难的题,虽然当时感觉很绝望,也很像放弃不去做,但是最终还是坚持了下来,并且独立完成了他们.</p>
<h1 id="痛苦着-折磨着-欢乐着"><a href="#痛苦着-折磨着-欢乐着" class="headerlink" title="痛苦着,折磨着,欢乐着"></a>痛苦着,折磨着,欢乐着</h1><p>尽管每节课大约只有2-3小时,但是由于每节课后都有5到8个习题,通常需要花费一周的时间才能完成两节课的学习.接着是week2的数组内容,紧随其后的是week3关于算法的课程.那时候,算法的习题让我十分头疼,因为我的水平还非常有限.最后一个习题是Tideman选举程序,如果没记错的话,我前前后后大概花了8个小时才完成它,确实让人感到有些沮丧(╥﹏╥).</p>
<p>在week3关于算法的部分,课程实际上也讲到了归并排序.不过,老师主要强调的是理论概念和思路,而不是具体的代码实现.之前的习题中,选择排序和冒泡排序已经被应用过了.我一度以为会有个挑战性的习题会是手撕归并排序.但是并没有这个内容,在完成了Tideman之后,我突然感觉归并排序似乎并不那么难了.于是我就试着自己动手编写了一个归并排序算法.尽管过程中遇到了许多语法错误,还有很多次的调试,但最终还是成功实现了.不得不承认,那时候写的代码很粗糙,而且我还没有养成写注释的好习惯.</p>
<p>当时手撕归并的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> n1 = m - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[l + i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">        R[j] = arr[m + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    k = l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(arr, l, m);</span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr_size = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给定的数组是 \n&quot;</span>);</span><br><span class="line">    printArray(arr, arr_size);</span><br><span class="line"></span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr_size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n排序后的数组是 \n&quot;</span>);</span><br><span class="line">    printArray(arr, arr_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从一开始连编写一个简单的for循环都觉得艰难,到两周后可以解决算法习题,并且手撕归并排序,尽管整个过程非常艰辛,但是克服困难之后的成就感也同样强烈.这样就形成了一个循环:继续学习 - 攻克难题 - 获得满足感 - 再次继续学习.</p>
<h1 id="C的落幕"><a href="#C的落幕" class="headerlink" title="C的落幕"></a>C的落幕</h1><p>从第一周开始,其实就一直在用c语音进行讲解,week4,week5又继续用c语言学了内存和数据结构.指针和数据结构这里其实是我向往已久的部分.因为网上常说指针很难搞懂,数据结构很复杂,确实这种言论如同潘多拉的魔盒一样吸引人的好奇.但是马兰教授仅用两节课的时间,就把相关概念讲得十分透彻,只听课的时候,我就感觉我又行了!区区指针就这?区区数据结构就这?不过做题的时候还是被打入了现实.”md!这是啥,完全看不懂啊!””这又是啥,完全没见过啊!”但当我冷静下来,细致地思考并回想课堂上的讲解,一层层抽丝剥茧,最终还是攻克了难关.</p>
<p>week5最后c语言综合题完成后,c语言这里也落下帷幕了.终于可以走出原始社会,回归现代社会的拥抱了,<strong>再见了小CC(¬‿¬)!</strong></p>
<h1 id="博客起航"><a href="#博客起航" class="headerlink" title="博客起航"></a>博客起航</h1><p>后面week6讲了python,week7讲了SQL,week8讲了前端三件套(HTML,CSS,JavaScript),week9讲了Flask框架.从高级语言,到数据库,到前端,然后再到后端.</p>
<p>马兰教授基本做到了覆盖互联网知识的讲解,虽然都是通识课,都是很浅的皮毛.但是马兰教授在课上给大家灌输正确学习的思想,还有教授大家如何学习的能力.告诉大家要自己去查询文档,以后如果出来最新技术应该怎样去学习,这些东西的意义感觉对初学者是意义非凡的.其实我在b站上看过一些这些所谓教育机构的视频,但是他们更多的是机械性的给灌注用法和内容.但是马兰教授讲课的时候,其实都是很快的过内容,更多的是思想还有方法的讲解,毕竟像python,SQL,前端三件套等等都是一节课就讲完.没有直接给你一箩筐鱼,而是教授了你捕鱼的方法. 我搭建博客的想法,其实是因为week8的最后一题,就是让自己做个网页.当时就想既然这样,何不直接做个博客呢?于是乎,经过了将近10天的旅程,我的博客诞生了. </p>
<h1 id="成长与收获"><a href="#成长与收获" class="headerlink" title="成长与收获"></a>成长与收获</h1><p>原本以为30小时内可以看完的课程,包括建博客在内,我大概经历了300小时才完全落幕.原本一周的计划也被拉到了一个多月.虽然时间花费很长,但感觉到自己的明显成长.CS50x虽然只讲解了最基础的通识内容,但我收获更多的是学习方法和编程思想,这些对我来说非常宝贵.</p>
<p>对有兴趣了解计算机的朋友,我强烈推荐观看<a href="https://cs50.harvard.edu/x/2023/">CS50x</a>,这是该课程的原版视频.如果你的英语水平不高,可以先从B站的<a href="https://www.bilibili.com/video/BV1XF411y7iJ/?spm_id_from=333.788&vd_source=a17da68960ea5515bbca2ea1b3a4365a">中文精翻版本</a>开始观看.除了week8和week9,我把所有习题都放到我的GitHub上的CS50仓库里,以供学习的朋友们参考—–本人强烈建议一定要完成所有周的课后题,这些题都非常好,你独立做完后,其实就完全消化和掌握了课上所讲的内容.虽然课上内容都很简单,但是如果只听的话还是很难做到真正内化的.所有题都独立跟做出来,你的成长一定很明显!</p>
<p>此外,还要向大家推荐由北大学长创建的<a href="https://csdiy.wiki/">CS自学手册</a>.这个资源汇集了哈佛&#x2F;斯坦福&#x2F;MIT&#x2F;UCB等多所知名学府的高质量课程,我也是根据这些资源和一些经典书籍进行学习的.感觉确实获益匪浅.</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习随笔-静态成员</title>
    <url>/2023/11/21/1/</url>
    <content><![CDATA[<h1 id="静态成员中遇到的问题"><a href="#静态成员中遇到的问题" class="headerlink" title="静态成员中遇到的问题"></a>静态成员中遇到的问题</h1><p>今天学到C++的静态成员时,由于一处报错,让自己感觉到这块当时并没有完全学明白,代码片段如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;	   </span><br><span class="line">		<span class="comment">//m_B = 100;  //静态成员函数不可以访问非静态成员变量</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;static void func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B;	<span class="comment">//非静态成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中被注释掉的m_B是报错的部分,因为这个地方的报错其实在我大脑中抛出了两个问题,后面的部分也是围着这两个部分去写的,刚入坑的小白也可以一起思考一下:</p>
<p><strong style="background-color: blue; color: white;">1.为什么静态成员函数不可以访问非静态成员变量?</strong><br><strong style="background-color: blue; color: white;">2.静态成员函数和静态成员变量的核心表达是什么?</strong></p>
<span id="more"></span>

<h1 id="为什么静态成员函数不可以访问非静态成员变量"><a href="#为什么静态成员函数不可以访问非静态成员变量" class="headerlink" title="为什么静态成员函数不可以访问非静态成员变量?"></a>为什么静态成员函数不可以访问非静态成员变量?</h1><h2 id="用定义去讲"><a href="#用定义去讲" class="headerlink" title="用定义去讲"></a>用定义去讲</h2><p>原因在于它们的存储方式和作用域.静态成员函数是属于类本身的,而不是类的具体实例.这意味着在没有创建对象的情况下,就可以调用静态成员函数.</p>
<p>由于静态成员函数不依赖于任何特定的对象实例来存在,它就没有办法确定应该访问哪一个对象的非静态成员变量.因为每一个对象的非静态成员变量都是独立分配的内存空间,每个对象的非静态成员变量值都可能不同.所以在设计时规定静态成员函数不能直接访问非静态成员变量,因为它们不属于任何一个对象实例.</p>
<h2 id="用人话来讲"><a href="#用人话来讲" class="headerlink" title="用人话来讲"></a>用人话来讲</h2><p>大家应该都不会喜欢一堆枯燥的文字,一下用个比喻来讲解一下就是:</p>
<div style="background-color: lightblue;">
    <p>想象一下,有一个大班级,里面有很多学生.这个班级(类)有一个规则(静态成员变量),比如说上课时间是早上8点开始,这个规则对所有学生(对象)都是一样的.</p>
    <p>现在,假设你是那个负责告知规则的广播员(静态成员函数).你只能宣布全班统一的规则,比如上课时间.但是你不知道每个学生个人的信息,比如每个学生的名字或者他们的分数(非静态成员变量),因为这些信息是每个学生独有的,与其他同学无关.</p>
    <p>所以作为广播员,你可以说:"注意,所有学生请在早上8点到教室上课." 但你不能说:"小明今天的分数是90分." 因为在没有具体指明是哪个学生的情况下,这句话对于全班来说没有意义,其他学生会困惑,不知道这个信息跟他们有什么关系.</p>
</div>

<p>回到编程中的静态成员函数,它就像班级里的广播员,可以公布对整个班级(类)通用的信息(静态成员变量),但是它不能处理个别学生(对象)的私有信息(非静态成员变量)因为没有指定到底是哪个学生的信息.而且在编程中,静态成员函数甚至没有办法确定是否存在任何学生(对象是否已经被创建),因为静态成员函数与对象的创建无关.</p>
<h1 id="静态成员函数和静态成员变量的核心表达是什么"><a href="#静态成员函数和静态成员变量的核心表达是什么" class="headerlink" title="静态成员函数和静态成员变量的核心表达是什么?"></a>静态成员函数和静态成员变量的核心表达是什么?</h1><p>静态成员变量和静态成员函数是类的两种特殊类型的成员,它们与类的实例(也就是对象)没有直接的关联.</p>
<h2 id="以下是他们的一些核心表达"><a href="#以下是他们的一些核心表达" class="headerlink" title="以下是他们的一些核心表达:"></a>以下是他们的一些核心表达:</h2><p><strong>1.静态成员变量:</strong><br>静态成员变量属于整个类,不归任何单一的对象所有,而是属于类本身.你可以将其视为类的全局变量.由于静态成员变量属于类,因此它们被该类的所有对象共享.在任何地方修改了这个变量,改变对所有使用这个变量的对象都是可见的.静态成员变量在程序开始时分配内存,并且只初始化一次,在程序结束时释放.静态成员变量独立于对象存在,即使没有创建类的对象,这个变量也存在.</p>
<p><strong>2.静态成员函数:</strong><br>静态成员函数不需要对象就可以调用,它们可以直接通过类来调用,不必先创建对象.静态成员函数仅能访问类的静态成员变量或其他静态成员函数,它们不能访问类的非静态成员变量或成员函数,因为后者依赖于具体的对象实例.静态成员函数通常用于执行与对象无关的操作,例如进行数学计算或处理静态成员变量.</p>
<p><strong>总的来说,静态成员(无论是变量还是函数)更像是与类相关联的全局元素.它们为类提供了一种方法来保持跨多个对象的状态,或者提供服务工具函数,而这些并不需要依附于类的具体实例.</strong></p>
<h2 id="用个比喻来讲"><a href="#用个比喻来讲" class="headerlink" title="用个比喻来讲"></a>用个比喻来讲</h2><p>想象一家餐厅(这家餐厅就是一个类),它有一个大钟表(静态成员变量)挂在墙上.这个大钟表对所有进入餐厅的人(对象或类的实例)都可见,并且不管是谁看到的时间都是一样的.如果这个钟慢了,所有人都会受到影响,因为它是共享的.这就是静态成员变量的意思__它是所有对象共用的.</p>
<p>现在,这家餐厅还提供了一个电话预订服务(静态成员函数),任何人(不必是餐厅里的顾客)都可以打电话来预订座位,而不需要亲自到餐厅来.这个电话服务不依赖于餐厅内部的任何特定客户或事物,它是独立存在的.这正像静态成员函数__你不需要一个对象的实例就能调用它,并且它处理的事情不涉及具体的对象.</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>博主现在还在不断学习阶段,认知有限,见识也很浅薄,如果有什么理解错的地方还望大佬们不吝指正.</p>
<p>后续我会不断分享一些自己学习过程中感觉比较难懂的地方,还有一些问题刨根问底的探究.</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
